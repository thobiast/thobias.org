<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<TITLE>CGI em Shell Script</TITLE>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VD2KWGETMN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VD2KWGETMN');
</script>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<P ALIGN="center"><CENTER><H1>CGI em Shell Script</H1>
<FONT SIZE=4>
<I>Thobias Salazar Trevisan</I><BR>
08/04/2003
</FONT></CENTER>

<P>
<HR NOSHADE SIZE=1>
<P>
<P>
 <OL>
 <LI><A HREF="#toc1">Introdução</A>
 <LI><A HREF="#toc2">Configuração</A>
   <UL>
   <LI><A HREF="#toc3">2.0.1. Algumas considerações importantes:</A>
   </UL>
 <LI><A HREF="#toc4">Diversão</A>
  <UL>
  <LI><A HREF="#toc5">3.1. Iniciando</A>
  <LI><A HREF="#toc6">3.2. Método GET</A>
  <LI><A HREF="#toc7">3.3. Método POST</A>
  <LI><A HREF="#toc8">3.4. Upload</A>
  <LI><A HREF="#toc9">3.5. CheckBox</A>
  <LI><A HREF="#toc10">3.6. Radio Buttons</A>
  <LI><A HREF="#toc11">3.7. Contador de Acesso Genérico</A>
   <UL>
   <LI><A HREF="#toc12">3.7.1. SSI - Server Side Includes</A>
   <LI><A HREF="#toc13">3.7.2. Contador</A>
   </UL>
  <LI><A HREF="#toc14">3.8. Segurança</A>
   <UL>
   <LI><A HREF="#toc15">3.8.1. Introdução e Configuração</A>
   <LI><A HREF="#toc16">3.8.2. Tá, e daí? Onde está o CGI em Shell?</A>
   </UL>
  </UL>
 <LI><A HREF="#toc17">LAN  +_+</A>
 <LI><A HREF="#toc18">Resumão</A>
 </OL>
<P>
<HR NOSHADE SIZE=1>
<P>
<P>
<a name="toc1"></a>
<H1>1. Introdução</H1>
<P>
CGI (Common Gateway Interface) é um serviço server-based o qual adiciona
funcionalidade extra a uma página. Esta funcionalidade é fornecida
por um 'pequeno' programa ou 'script' que é executado no servidor onde a
página web fica. Estes programas podem ser feitos em diversas linguagens
como Perl, PHP, C, Shell Script, etc.
<P>
Como gosto muito de Shell Script resolvi escrever um tutorial básico
sobre como fazer CGI em Shell. Isto tem várias vantagens, pois você pode 
utilizar vários comandos do UNIX para ajudar a construir seu script, 
por exemplo sed, awk, cut, grep, cat, echo, bc, etc. além dos recursos 
do próprio shell.
<P>
Ok, como este tutorial não vai ser muito grande, vamos direto ao ponto.
<P>
<a name="toc2"></a>
<H1>2. Configuração</H1>
<P>
Como configurar o servidor web Apache para executar CGI ?
<P>
CGI é um módulo do Apache, assim ele precisa ser carregado.
A maioria das distribuições já vem com o seu <I>httpd.conf</I> configurado com
suporte ao módulo do CGI (mod_cgi), bastando apenas iniciar o Apache. 
Para se certificar procure e, se for o caso, descomente a seguinte 
linha no seu <I>httpd.conf</I>: 
<P>
<PRE>
  LoadModule cgi_module /usr/lib/apache/1.3/mod_cgi.so
</PRE>
<P>
<B>PS:</B> Note que a terceira coluna pode variar dependendo da versão do
Apache e da distribuição que você está usando.
<P>
Existem diversas maneiras de configurá-lo: 
<P>
<OL>
<LI>ScriptAlias
<P>
esta diretiva define um diretório para o Apache onde serão armazenados os
scripts CGI. Todos os arquivos que estiverem neste diretório serão
interpretados pelo Apache como programas CGI, assim ele tentará executá-los. 
Adicione ou descomente a seguinte linha no seu arquivo <I>httpd.conf</I>
<PRE>
  ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/ 
</PRE>
<P>
<P>
O exemplo acima instrui o Apache para que qualquer requisição começando por
/<I>cgi-bin</I>/ deva ser acessada no diretório /<I>usr/lib/cgi-bin</I>/ e deva
ser tratada como um programa CGI, i.e., ele irá executar o arquivo
requisitado.
<P>
se você acessar por exemplo <CODE>http://localhost/cgi-bin/meu_script.cgi</CODE>, o
Apache irá procurar este arquivo em
/<I>usr/lib/cgi-bin/meu_script.cgi</I> e tentará executá-lo.
<P>
<LI>fora do ScriptAlias
<P>
você pode especificar um diretório particular e dar permissão para a
execução de CGIs.
<PRE>
  &lt;Directory /home/user/public_html/cgi-bin/&gt;
                  Options +ExecCGI
  &lt;/Directory&gt;
</PRE>
<P>
<P>
esta diretiva acima permite a execução de CGIs, mas você ainda precisa 
avisar o Apache que tipo de arquivos são estes CGIs. Procure 
por uma linha igual ou semelhante a esta no seu <I>httpd.conf </I>e descomente.
<PRE>
  AddHandler cgi-script .cgi .sh .pl
</PRE>
</OL>
OBS: se você colocar um index.cgi em algum diretório e quiser que por
default o Apache execute-o, não se esqueça de adicionar esta extensão no
seu <I>DirectoryIndex</I>.
<P>
<PRE>
  &lt;IfModule mod_dir.c&gt;
      DirectoryIndex index.html index.htm index.shtml index.cgi
  &lt;/IfModule&gt;
</PRE>
<P>
O Apache irá procurar pelo index.cgi seguindo a ordem dos argumentos, ou
seja, o index.cgi será a última opção que ele irá procurar no diretório.
<P>
<a name="toc3"></a>
<H3>2.0.1. Algumas considerações importantes:</H3>
<P>
 <UL>
 <LI>você não deve colocar seus scripts no document root do Apache,
porque alguém pode pegar seus scripts, analisá-los procurando furos de
segurança, etc. Além do mais, o código do script não é o que você quer
mostrar :)  Então mantenha-os em /<I>usr/lib/cgi-bin</I> ou algum outro diretório
fora do document root.
<P>
 <LI>o script precisa ser um executável, não se esqueça de dar um <I>chmod</I>
nele. Ah, certifique que o script tem permissão de execução para o usuário
que o Apache está rodando.
 </UL>
<a name="toc4"></a>
<H1>3. Diversão</H1>
<a name="toc5"></a>
<H2>3.1. Iniciando</H2>
Assumimos que você já tem o seu servidor web configurado para executar
CGI. Agora é hora da diversão :-)
<P>
O básico que você precisa saber é que toda a saída padrão (stdout) do seu 
script vai ser enviada para o browser.
<P>
O exemplo mais simples é você imprimir algo na tela. Vamos ao nosso exemplo:
<P>
<PRE>
  ================ simples.cgi ====================
  #!/bin/bash
  
  echo "content-type: text/plain"
  echo
  echo -e "
  vamos ver se isto funciona mesmo :-)
  
  hmm, parece legal
  
  igual ah um shell normal \n&lt;b&gt;tag html&lt;/b&gt;
  "
  =================================================
</PRE>
<P>
Feito isto basta acessar o nosso arquivo.
<A HREF="http://localhost/cgi-bin/simples.cgi">http://localhost/cgi-bin/simples.cgi</A>
Ah, não se esqueça de colocar permissão de execução no arquivo
<P>
Ok, então percebemos que toda saída do nosso script é enviada para o
browser, toda a saída mesmo. Por exemplo, podemos utilizar a saída de um
comando: 
<P>
<PRE>
  ================ saida_cmd.cgi ==================
  #!/bin/bash
  
  echo "content-type: text/plain"
  echo 
  echo "uname -a"
  echo
  uname -a
  =================================================
</PRE>
<P>
Quando utilizamos CGI o servidor coloca diversas informações sobre
o cliente e o servidor em variáveis de ambiente. Dentre estas informações
pode-se destacar:
<P>
<table align="center" cellpadding=4 border=0>
<tr>
<td><I>DOCUMENT_ROOT</I></td>
<td>diretório root dos documentos html</td>
</tr>
<tr>
<td><I>HTTP_ACCEPT</I></td>
<td>quais os content-type suportados pelo browser do cliente</td>
</tr>
<tr>
<td><I>HTTP_HOST</I></td>
<td>nome do host do servidor</td>
</tr>
<tr>
<td><I>HTTP_USER_AGENT</I></td>
<td>o browser do cliente</td>
</tr>
<tr>
<td><I>REMOTE_ADDR</I></td>
<td>IP do cliente</td>
</tr>
<tr>
<td><I>REQUEST_URI</I></td>
<td>página requisitada</td>
</tr>
<tr>
<td><I>SERVER_ADDR</I></td>
<td>IP do servidor</td>
</tr>
<tr>
<td><I>SERVER_NAME</I></td>
<td>o server name (configurado no Apache)</td>
</tr>
<tr>
<td><I>SERVER_PORT</I></td>
<td>porta que o servidor está escutando</td>
</tr>
<tr>
<td><I>SERVER_SOFTWARE</I></td>
<td>sistema operacional e servidor www rodando no server</td>
</tr>
</table>

<P>
Para a lista completa destas variáveis acesse <A HREF="http://hoohoo.ncsa.uiuc.edu/cgi/env.html">http://hoohoo.ncsa.uiuc.edu/cgi/env.html</A>.
<P>
O exemplo a seguir mostra todas as variáveis.
<P>
<PRE>
  ================ export.cgi =====================
  #!/bin/bash
  
  echo "content-type: text/plain"
  echo
  echo "
  Informacoes que o servidor coloca em variaveis de ambiente
  Para ver utilizamos o comando set
  
  "
  set
  =================================================
</PRE>
<P>
Okay, no protocolo http temos que enviar um cabeçalho obrigatório. 
O primeiro echo sem string dentro de um script vai avisar o browser para 
interpretar o que veio antes como cabeçalho. Nos exemplos anteriores, a
seguinte linha  <I>content-type: text/plain</I>  informa ao browser
para interpretar o que receber como texto puro. Se o cabeçalho não possuir
nenhuma linha, ou seja, colocarmos somente um echo, será utilizado o default 
que normalmente é <I>text/plain</I>.
Este default é configurado no arquivo <I>httpd.conf</I> do Apache na opção:
<P>
<PRE>
  DefaultType text/plain
</PRE>
<P>
Então para garantir procure sempre especificar o cabeçalho!!
Para enviarmos tags html e o browser interpretá-las, temos que utilizar um
cabeçalho diferente. Este cabeçalho é <I>content-type: text/html</I>
Então vamos enviar tags html para deixar nossa saída mais bonita:
<P>
<PRE>
  ================ sobre.cgi ======================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo
  echo "
  &lt;html&gt; &lt;head&gt; &lt;title&gt; CGI script &lt;/title&gt; &lt;/head&gt;
  &lt;body&gt;
  &lt;h1&gt;Algumas informações sobre a máquina que o CGI está rodando:&lt;/h1&gt;
  "
  
  echo "&lt;h4&gt;uptime&lt;/h4&gt;"
  echo "&lt;pre&gt;$(uptime)&lt;/pre&gt;"
  
  echo "&lt;h4&gt;uname&lt;/h4&gt;"
  echo "&lt;pre&gt;$(uname -a)&lt;/pre&gt;"
  
  echo "&lt;h4&gt;/proc/cpuinfo&lt;/h4&gt;"
  echo "&lt;pre&gt;$(cat /proc/cpuinfo)&lt;/pre&gt;"
  
  echo "
  &lt;/body&gt;
  &lt;/html&gt;
  "
  =================================================
</PRE>
<P>
Um exemplo mais interessante seria como fazer um contador de acesso.
A cada execução do script o contador será incrementado, não importando se é
uma solicitação de reload de um mesmo endereço IP!!
Isto é simples. Veja o exemplo: 
<P>
<PRE>
  ================ contador.cgi ===================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo
  echo "&lt;html&gt; &lt;head&gt; &lt;title&gt; CGI script &lt;/title&gt; &lt;/head&gt;"
  echo "&lt;body&gt;"
  
  ARQ="/tmp/page.hits"
  
  n="$(cat $ARQ 2&gt; /dev/null)" || n=0
  echo $((n=n+1)) &gt; "$ARQ"
  
  echo "
  &lt;h1&gt;Esta página já foi visualizada: $n vezes&lt;/h1&gt;
  &lt;br&gt;
  
  &lt;/body&gt;
  &lt;/html&gt;"
  =================================================
</PRE>
<P>
Com o que sabemos até agora, dá (ops!) para fazer vários script legais, 
fazer monitoramento do sistema, de sua rede..., tudo via web.
<P>
Agora que já aprendemos o básico, queremos interagir com o usuário.
Neste ponto nós temos um detalhe, pois o nosso script não pode usar a
entrada padrão (stdin) para receber dados e não podemos fazer um <I>read</I> em um
CGI, pois como nós leriamos o que o usuário digitasse no teclado? :) 
<P>
Para realizar esta interação existem duas maneiras. 
<P>
<OL>
<LI>através da URL, utilizando o método GET, como por exemplo:
<P>
<CODE>http://localhost/cgi-bin/script.cgi?user=nobody&amp;profissao=vaga</CODE>
<P>
(veremos mais sobre o método GET mais adiante)
<P>
<LI>utilizando um formulário HTML. No FORM podemos utilizar dois métodos, o GET
e o POST. No método GET, que é o default, os campos de input do FORM são
concatenados a URL. Já no método POST, os inputs são passados internamente do
servidor para o script pela entrada padrão.
</OL>
<a name="toc6"></a>
<H2>3.2. Método GET</H2>
<P>
Usando o método GET o nosso script deve pegar os inputs do usuário
via uma variável de ambiente, no caso a <B><I>$QUERY_STRING</I></B>.
Tudo o que vier após o caractere '?' na URL será colocado naquela variável.
Os campos de input do FORM são separados pelo caractere '&amp;' e
possuem a seguinte construção: <I>name=value</I>.
Vamos a um exemplo de um CGI que recebe como entrada um host
que será executado no ping.
<P>
<PRE>
  ================ ping_get.cgi ===================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo
  echo "
  &lt;html&gt; &lt;head&gt; &lt;title&gt; CGI script &lt;/title&gt; &lt;/head&gt;
  &lt;body&gt;
  "
  
  echo "&lt;h2&gt;Exemplo de uso do GET&lt;/h2&gt;"
  if [ "$QUERY_STRING" ];then
  	echo "QUERY_STRING   $QUERY_STRING"
  	host="$(echo $QUERY_STRING | sed 's/\(.*=\)\(.*\)\(\&amp;.*\)/\2/')"
  	echo "&lt;br&gt;"
  	echo "Disparando o comando ping para o host &lt;b&gt;$host&lt;/b&gt;"
  	echo "&lt;pre&gt;"
  	ping -c5 $host
  	echo "&lt;/pre&gt;"
  	echo "Fim."
  else
  	echo "
  	&lt;form method=\"GET\" action=\"ping_get.cgi\"&gt;
  	&lt;b&gt;Entre com o nome ou IP do host para o ping:&lt;/b&gt; 
  	&lt;input size=40 name=host value=\"\"&gt;
  	&lt;input type=hidden size=40 name=teste value=\"nada\"&gt;
  	&lt;/form&gt;"
  fi
  
  echo "&lt;/body&gt;"
  echo "&lt;/html&gt;"
  =================================================
</PRE>
<P>
<a name="toc7"></a>
<H2>3.3. Método POST</H2>
<P>
No método POST as opções do FORM não são passadas pela URL, elas são
passadas internamente do servidor para o CGI. Deste modo, com este
método o nosso script deve ler as opções pela entrada padrão. Vamos a um
exemplo em que o CGI envia um mail para alguém através da página. Neste
caso, um pouco mais complexo, temos dois arquivos. O primeiro um .html
puro, onde construimos o FORM, e colocamos como opção '<I>action</I>' o nosso
script. A opção action passada no FORM, indica qual script será chamado
para tratar os dados passados pelo FORM.
<P>
<PRE>
  ================ contato.html ===================
  &lt;html&gt; &lt;head&gt; &lt;title&gt; CGI script &lt;/title&gt; &lt;/head&gt;
  
  &lt;body&gt;
  &lt;form method="post" action="/cgi-bin/contato.cgi"&gt;
  Nome:&lt;br&gt;
  &lt;input type="text" name="name" maxlength="50" size="30"&gt;
  &lt;p&gt;
  E-mail:&lt;br&gt;
  &lt;input type="text" name="address" maxlength="50" size="30"&gt;
  &lt;p&gt;
  Selecione o assunto:
  &lt;select name="subject"&gt;
  &lt;option value="none"&gt;-------------------------
  &lt;option value="venda"&gt;Informações sobre produto
  &lt;option value="suporte"&gt;Suporte técnico  
  &lt;option value="web"&gt;Problema no site
  &lt;/select&gt;
  &lt;p&gt;
  Sua mensagem:&lt;br&gt;
  &lt;textarea name="message" wrap="physical" rows="6" cols="50"&gt;
  &lt;/textarea&gt;
  &lt;p&gt;
  &lt;input type="submit" value="Enviar Mensagem"&gt;
  &lt;input type="reset" value="Limpar"&gt;
  &lt;/form&gt;
  
  &lt;/body&gt;
  &lt;/html&gt;
  =================================================
</PRE>
<P>
Agora o nosso script lê da entrada padrão e faz o tratamento necessário.
Note que para enviar o mail, podemos utilizar qualquer programa de mail,
por exemplo o mail, sendmail...
<P>
<PRE>
  ================ contato.cgi ====================
  #!/bin/bash
  
  meu_mail="user@localhost.com.br"
  
  echo "content-type: text/html"
  echo
  echo
  echo "&lt;html&gt; &lt;head&gt; &lt;title&gt; CGI script &lt;/title&gt; &lt;/head&gt;"
  echo "&lt;body&gt;"
  VAR=$(sed -n '1p')
  echo "$VAR"
  nome=$(echo $VAR | sed 's/\(name=\)\(.*\)\(\&amp;address=.*\)/\2/;s/+/ /g')
  mail=$(echo $VAR | sed 's/\(.*&amp;address=\)\(.*\)\(\&amp;subject=.*\)/\2/;s/%40/@/')
  subj=$(echo $VAR | sed 's/\(.*&amp;subject=\)\(.*\)\(\&amp;message=.*\)/\2/')
  text=$(echo $VAR |  sed 's/.*\&amp;message=//')
  
  echo "&lt;br&gt;
  &lt;br&gt;&lt;b&gt;Nome:&lt;/b&gt; $nome
  &lt;br&gt;&lt;b&gt;mail:&lt;/b&gt; $mail
  &lt;br&gt;&lt;b&gt;Subject:&lt;/b&gt; $subj
  &lt;br&gt;&lt;b&gt;Message:&lt;/b&gt; $text
  &lt;br&gt;"
  
  mail -s "Mail from CGI" "$meu_mail" &lt; $(echo -e "
  Nome: $nome 
  mail: $mail
  Subject: $subj
  Message: $text")
  
  echo "&lt;/body&gt;"
  echo "&lt;/html&gt;"
  =================================================
</PRE>
<P>
Quando o seu servidor web envia os dados do FORM para o seu CGI, ele faz 
um encode dos dados recebidos. Caracteres alfanumérico são enviados
normalmente, espaços são convertidos para o sinal de mais (+), outros
caracteres como tab, aspas são convertidos para %HH, onde HH são dois
dígitos hexadecimais representando o código ASCII do caractere. Este
processo é chamado de URL encoding.
<P>
Tabela para os caracteres mais comuns:
<P>
<table align="center" cellpadding=4 border=1>
<tr>
<th>Caractere</th>
<th>URL Enconded</th>
</tr>
<tr>
<td align="center">\t (tab)</td>
<td align="center">%09</td>
</tr>
<tr>
<td>\n (return)</td>
<td align="center">%0A</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">%2F</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">%7E</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">%3A</td>
</tr>
<tr>
<td align="center">;</td>
<td align="center">%3B</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">%40</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">%26</td>
</tr>
</table>

<P>
Aqui vão dois links para fazer e desfazer esta conversão:
<UL>
<LI><A HREF="http://www.shelldorado.com/scripts/cmds/urlencode">http://www.shelldorado.com/scripts/cmds/urlencode</A>
<LI><A HREF="http://www.shelldorado.com/scripts/cmds/urldecode">http://www.shelldorado.com/scripts/cmds/urldecode</A>
</UL>
<a name="toc8"></a>
<H2>3.4. Upload</H2>
Agora que já sabemos utilizar os métodos GET e POST vamos a um exemplo um
pouco diferente. Vamos supor que precisamos fazer um CGI que permita
o usuário fazer um upload de um arquivo para o servidor. Aqui utilizamos um
FORM um pouco diferente. Falamos para o FORM utilizar um tipo de codificação
diferente, no caso <I>enctype="multipart/form-data"</I>.
Criamos um HTML normalmente e como opção do <I>action</I> colocamos o nosso script.
<P>
<PRE>
  ================ upload.html ====================
  &lt;html&gt;
  &lt;body&gt;
  &lt;form enctype="multipart/form-data" action="/cgi-bin/upload.cgi" method="post"&gt;
  Enviar arquivo: &lt;input name="userfile" size="30" type="file"&gt;
  &lt;BR&gt;&lt;BR&gt;
  &lt;input type="submit" value="Envia" name="Envia"&gt;
  &lt;/form&gt;
  &lt;/body&gt;
  &lt;/html&gt;
  =================================================
</PRE>
<P>
O nosso script é quase igual a um POST normal. A principal diferença é que
o input para o script não vem em uma única linha, e sim em várias.
Quem faz isto é o <I>enctype="multipart/form-data"</I>.
Vem inclusive o conteúdo do arquivo via POST!! Então pegamos tudo da entrada
padrão. Note que junto com o input vem outras cositas mas =8)
Vamos a um exemplo:
<P>
<PRE>
  ================ upload.cgi =====================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo
  echo "&lt;html&gt; &lt;head&gt; &lt;title&gt; CGI script &lt;/title&gt; &lt;/head&gt;"
  echo "&lt;body&gt;&lt;pre&gt;"
  # descomente se quiser ver as variaveis de ambiente
  #export
  
  # ele separa as varias partes do FORM usando um limite (boundary) que eh
  # diferente a cada execucao. Este limite vem na variavel de ambiente CONTENT_TYPE
  # algo mais ou menos assim
  # CONTENT_TYPE="multipart/form-data; boundary=--------------1086400738455992438608787998"
  # Aqui pegamos este limite
  boundary=$(export | sed '/CONTENT_TYPE/!d;s/^.*dary=//;s/.$//')
  
  #echo
  #echo "boundary = $boundary"
  
  # pegamos toda a entrada do POST e colocamos em VAR
  VAR=$(sed -n '1,$p')
  # imprimimos o que vem no input
  echo "$VAR"
  echo -e '\n\n'
  echo "================= FIM ============================="
  echo -e '\n\n'
  # pegamos o nome do arquivo que foi feito o upload
  FILENAME=$(echo "$VAR" | sed -n '2!d;s/\(.*filename=\"\)\(.*\)\".*$/\2/;p')
  
  # pegamos somente o conteudo do arquivo do upload
  FILE=$(echo "$VAR" | sed -n "1,/$boundary/p" | sed '1,4d;$d')
  
  echo "Nome do arquivo : $FILENAME"
  echo
  # imprimimos no browser o conteudo do arquivo
  echo "$FILE"  
  # redirecionamos o conteudo do arquivo para um arquivo local no server
  # upload feito ;)
  echo "$FILE" | sed '$d' &gt; "/tmp/$FILENAME" 
  
  echo "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"
  =================================================
</PRE>
<P>
<a name="toc9"></a>
<H2>3.5. CheckBox</H2>
Para relaxar um exemplo mais simples, vamos fazer um CheckBox.
Primeiro criamos uma página HTML com o FORM para checkbox normalmente. 
Vamos utilizar o método POST no exemplo.
<P>
<PRE>
  ================ checkbox.html ==================
  &lt;html&gt;&lt;head&gt;&lt;title&gt;distro&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
  
  &lt;form action="/cgi-bin/checkbox.cgi" method="POST"&gt;
  
  &lt;h3&gt;Quais destas distro voce gosta ?&lt;/h3&gt;
  &lt;input type="checkbox" name="debian" value=1&gt; Debian&lt;br&gt;
  &lt;input type="checkbox" name="redhat" value=1&gt; RedHat&lt;br&gt;
  &lt;input type="checkbox" name="conectiva" value=1&gt; Conectiva&lt;br&gt;
  &lt;input type="checkbox" name="mandrake" value=1&gt; Mandrake&lt;br&gt;
  &lt;input type="submit" value="Enviar"&gt;
  &lt;/form&gt;
  
  &lt;/body&gt;
  &lt;/html&gt;
  =================================================
</PRE>
<P>
Pegamos os inputs do FORM na entrada padrão. Eles são separados por &amp;.
Todas as opções que o usuário selecionar virão no POST. 
Ah, não se esqueça, <I>name=value</I>. Um exemplo de input que recereberemos:
<PRE>
  debian=1&amp;conectiva=1
</PRE>
Assim, sabemos que o usuário escolheu estas duas opções. Basta fazer o
script.
<P>
<PRE>
  ================ checkbox.cgi ===================
  #!/bin/bash
  
  echo "content-type: text/plain"
  echo 
  VAR=$(sed -n 1p)
  echo "$VAR"
  echo 
  [ "$VAR" ] || { echo "voce nao gosta de nada";exit; }
  echo "Voce gosta de :"
  echo
  IFS="&amp;"
  for i in `echo "$VAR"`;do
  echo " $(echo $i | cut -d= -f1)"
  done
  =================================================
</PRE>
<P>
<a name="toc10"></a>
<H2>3.6. Radio Buttons</H2>
Outro exemplo é o Radio Buttons.
Também utilizaremos o método POST aqui.
Criamos um html normalmente.
<P>
<PRE>
  ================ radiobuttons.html ==============
  &lt;html&gt;&lt;head&gt;&lt;title&gt;distro&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
  
  &lt;form action="/cgi-bin/radiobuttons.cgi" method="POST"&gt;
  
  &lt;h3&gt;Qual sua distro predileta ?&lt;/h3&gt;
  &lt;input type="radio" name="distro" value=Debian&gt; Debian&lt;br&gt;
  &lt;input type="radio" name="distro" value=RedHat&gt; RedHat&lt;br&gt;
  &lt;input type="radio" name="distro" value=Conectiva&gt; Conectiva&lt;br&gt;
  &lt;input type="radio" name="distro" value=Mandrake&gt; Mandrake&lt;br&gt;
  &lt;input type="radio" name="distro" value=none&gt; Nenhuma destas&lt;br&gt;
  &lt;input type="submit" value="Enviar"&gt;
  &lt;/form&gt;
  
  &lt;/body&gt;
  &lt;/html&gt;
  =================================================
</PRE>
<P>
O que será enviado pelo POST é o input escolhido. Como é Radio Buttons,
somente uma opção é aceita, assim temos o input: name=value, onde name é a
variável distro e value é a opção escolhida pelo usuário. Um exemplo é: 
<I>distro=Debian</I>
<P>
<PRE>
  ================ radiobuttons.cgi ===============
  #!/bin/bash
  
  echo "content-type: text/html" 
  echo 
  VAR=$(sed -n 1p)
  echo "$VAR &lt;br&gt;"
  echo "&lt;br&gt;"
  [ "$VAR" ] || { echo "voce nao gosta de nada";exit; }
  
  echo "Sua distro predileta eh: &lt;b&gt;$(echo $VAR | cut -d= -f2)&lt;/b&gt;"
  =================================================
</PRE>
<P>
<a name="toc11"></a>
<H2>3.7. Contador de Acesso Genérico</H2>
<P>
Um dos primeiros exemplos que vimos foi como fazer um contador de acesso
<I>contador.cgi</I>. Aquela implementação tem um problema de
concorrência. Se a página tiver 2 acessos 'simultâneos' ela pode deixar 
de contabilizar 1 acesso. Vamos imaginar que temos dois acessos a página
'ao mesmo tempo'. O fluxo de execução do CGI do primeiro acesso executa
as seguintes linhas:
<P>
<PRE>
  ARQ="/tmp/page.hits"
  n="$(cat $ARQ 2&gt; /dev/null)" || n=0
</PRE>
<P>
O kernel interrompe a execução do CGI neste momento e começa a executar o
CGI do segundo acesso a página. O segundo CGI é todo executado, assim, ele
leu o valor que tinha no arquivo /<I>tmp/page.hits</I>, somou 1 e sobrescreveu
o arquivo com o novo valor. Agora o kernel volta a executar o primeiro CGI de
onde parou, seguindo nosso algoritmo, o CGI já tem o valor antigo do
arquivo na variável <I>n</I>, assim ele vai para a próxima instrução:
<P>
<PRE>
   echo $((n=n+1)) &gt; "$ARQ"
</PRE>
<P>
Sobrescreveu o antigo valor. <B>Note</B>: como ele foi interrompido antes da
segunda execução do CGI, ele estava com o valor antigo em <I>n</I>. Nosso
contador perdeu 1 acesso. :/
<P>
Para arrumar este problema, vamos aproveitar e incluir um novo tópico aqui.
<P>
<a name="toc12"></a>
<H3>3.7.1. SSI - Server Side Includes</H3>
<P>
SSI são diretivas que colocamos em uma página HTML pura para que o
servidor avalie quando a página for acessada. Assim podemos adiconar
conteúdo dinâmico a página sem precisarmos escrever toda ela em CGI. Para
isto basta configurar o seu Apache corretamente. Quem fornece esta opção é
o módulo includes (mod_include), simplesmente descomentamos a linha que
carrega este módulo:
<P>
<PRE>
  LoadModule includes_module /usr/lib/apache/1.3/mod_include.so
</PRE>
<P>
Exitem duas maneiras de configurá-lo:
<P>
<OL>
<LI>através da extensão do arquivo, normalmente .shtml
<P>
<LI>através da opção XBitHack. Esta opção testa se o arquivo HTML (.html)
requisitado tem o bit de execução setado, se tiver ele executará o que
tiver usando as suas diretivas. Acrescente a seguinte linha em seu
<I>httpd.conf</I>.
<PRE>
  XBitHack on
</PRE>
</OL>
<B>PS</B>: em ambos os casos o arquivo HTML precisa ser executável.
<P>
Este tópico está muito bem documentado nos seguintes endereços:
<UL>
<LI><A HREF="http://httpd.apache.org/docs/howto/ssi.html">http://httpd.apache.org/docs/howto/ssi.html</A>
<LI><A HREF="http://httpd.apache.org/docs/mod/mod_include.html">http://httpd.apache.org/docs/mod/mod_include.html</A>
</UL>
<a name="toc13"></a>
<H3>3.7.2. Contador</H3>
<P>
Para resolver o problema de concorrência vamos utilizar um <I>named pipe</I>.
Criamos o seguinte script que será o daemon que receberá todos os pedidos
para incrementar o contador. Note que ele vai ser usado por qualquer
página no nosso site que precise de um contador.
<P>
<PRE>
  ================ daemon_contador.sh= ===========
  #!/bin/bash
  
  PIPE="/tmp/pipe_contador" # arquivo named pipe
  # dir onde serao colocados os arquivos contadores de cada pagina
  DIR="/var/www/contador"	  
  
  [ -p "$PIPE" ] || mkfifo "$PIPE"
  
  while :;do
  	for URL in $(cat &lt; $PIPE);do
  		FILE="$DIR/$(echo $URL | sed 's,.*/,,')"
  		# quando rodar como daemon comente a proxima linha
  		echo "arquivo = $FILE"
  
  		n="$(cat $FILE 2&gt; /dev/null)" || n=0
  		echo $((n=n+1)) &gt; "$FILE"
  	done
  done
  =================================================
</PRE>
<P>
Como só este script altera os arquivos, não existe problema de
concorrência.
<P>
Este script será um daemon, isto é, rodará em background. Quando uma página
sofrer um acesso, ela escreverá a sua URL no arquivo de pipe. Para testar,
execute este comando:
<P>
<PRE>
   echo "teste_pagina.html" &gt; /tmp/pipe_contador 
</PRE>
<P>
Em cada página que quisermos adicionar o contador acrescentamos a seguinte
linha:
<P>
<PRE>
  &lt;!--#exec cmd="echo $REQUEST_URI &gt; /tmp/pipe_contador"--&gt;
</PRE>
<P>
Note que a variável $REQUEST_URI contém o nome do arquivo que o browser
requisitou.
<P>
<B>PS</B>: assim que tiver tempo vou tentar explicar melhor este tópico. 
<P>
<a name="toc14"></a>
<H2>3.8. Segurança</H2>
<P>
<a name="toc15"></a>
<H3>3.8.1. Introdução e Configuração</H3>
<P>
Este é um tópico importante quando falamos sobre CGI, principalmente os que têm algum
tipo de interação com o usuário. Mas para aumentar um pouco a segurança de
nossos CGIs podemos utilizar a opção <I>AccessFileName</I> do Apache. Ela nos
permite especificar quais usuário terão acesso a um determinado diretório.
Por exemplo, podemos especificar quais usuários terão acesso aos scripts em 
<CODE>http://localhost/cgi-bin/controle/</CODE>
<P>
Primeiro vamos configurar o Apache. Procure e, se for o caso, descomente a
seguine linha em seu <I>httpd.conf</I>
<P>
<PRE>
  AccessFileName .htaccess
</PRE>
<P>
Esta opção define para o Apache o nome do arquivo que terá as informações
sobre o controle de acesso de cada diretório. Procure e, se for o caso,
descomente as seguintes linhas para não deixar nenhum usuário baixar nossos
arquivos de controle de acesso e de usuários e senhas.
<P>
<PRE>
  &lt;Files ~ "^\.ht"&gt;
      Order allow,deny
      Deny from all
  &lt;/Files&gt;
</PRE>
<P>
Este próximo passo é necessário porque normalmente a opção <I>AllowOverride</I> 
default é <I>None</I>. Assim, para cada diretório que você deseja ter este controle, 
adicione a seguinte linha em seu <I>httpd.conf</I>:
<P>
<PRE>
  &lt;Directory /diretorio/que/tera/htaccess/&gt;
      AllowOverride AuthConfig
  &lt;/Directory&gt;
</PRE>
<P>
Agora temos o nosso Apache configurado, vamos configurar o nosso <I>.htaccess</I>.
Este arquivo tem a seguinte estrutura:
<P>
<PRE>
  AuthName "Acesso Restrito"
  AuthType Basic
  AuthUserFile /PATH/TO/.htpasswd
  
  require valid-user
</PRE>
<P>
Onde:
<P>
<table align="center" cellpadding=4 border=1>
<tr>
<td align="center">AuthName</td>
<td>mensagem que irá aparecer quando pedir o username e passwd</td>
</tr>
<tr>
<td align="center">AuthType</td>
<td>normalmente é Basic</td>
</tr>
<tr>
<td align="center">AuthUserFile</td>
<td>o PATH para o arquivo que contém a lista de user e senha válido</td>
</tr>
<tr>
<td>require valid-user</td>
<td>especifica que somente usuários válidos terão acesso</td>
</tr>
</table>

<P>
Vamos a um exemplo. Vamos supor que queremos proteger o acesso ao diretório
/<I>usr/lib/cgi-bin/controle</I>. Configuramos o <I>httpd.conf</I> como descrito
acima. Depois criamos o seguinte arquivo neste diretório.
<P>
<PRE>
  AuthName "Acesso Restrito"
  AuthType Basic
  AuthUserFile /usr/lib/cgi-bin/controle/.htpasswd
  
  require valid-user
</PRE>
<P>
Feito isto, criamos o nosso arquivo com os usuários válidos.
<B>Importante</B>: os usuários que vamos criar não precisam existir na
máquina, i.e., não tem nenhuma relação com o arquivo /<I>etc/passwd</I>.
Para criar o arquivo utilizamos o comando: 
<P>
<PRE>
  htpasswd -m -c ./.htpasswd user
</PRE>
<P>
Após criarmos e adicionarmos o primeiro usuário, basta tirar a opção <I>-c</I>
do comando para adicionar novos usuários no mesmo arquivo. Exemplo:
<I>htpasswd -m ./.htpasswd outro_user</I>
<P>
OBS: a cada execução do comando aparecerá um prompt pedindo para definir
uma senha para o usuário. A opção -m serve para utilizar o algoritmo
MD5 modificado pelo Apache. Mais detalhes: <I>man htpasswd</I>
<P>
<a name="toc16"></a>
<H3>3.8.2. Tá, e daí? Onde está o CGI em Shell?</H3>
<P>
Calma, isto que vimos é Apache puro. Mas agora vem o pulo do gato :)
Vamos continuar nosso exemplo.
Crie o seguinte arquivo e coloque em /<I>usr/lib/cgi-bin/controle</I>
<P>
<PRE>
  ================ set.cgi =====================
  #!/bin/bash
  
  echo "content-type: text/plain"
  echo
  set
  =================================================
</PRE>
<P>
Depois acesse <CODE>http://localhost/cgi-bin/controle/set.cgi</CODE>.
Se tudo ocorreu bem, aparecerá uma tela pedindo usuário e senha. Entre com
um usuário e senha que você cadastrou em <I>./.htpasswd</I>.
Será mostrado todas as variáveis de ambiente. Dê uma olhada na variável
<B><I>REMOTE_USER</I></B>. É o nome do usuário que fez o login. Agora podemos ter
CGIs onde só determinados usuários podem acessar, e dentre estes usuários
só alguns terão acesso a certas opções do script, etc.
<P>
Um exemplo :) Vamos imaginar que só determinados usuários tem acesso ao CGI
de controle sobre a máquina. Então configuramos o Apache, criamos o
<I>.htaccess</I> e cadastramos os usuários válidos em <I>.htpasswd</I>, 
isto no diretório /<I>usr/lib/cgi-bin/controle</I>
<P>
Criamos o nosso script de controle:
<P>
<PRE>
  ================ controle.cgi ================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo "&lt;html&gt;&lt;head&gt;&lt;title&gt;Controle&lt;/title&gt;&lt;/head&gt;"
  echo "&lt;body&gt;"
  
  echo "Voce esta logado como usuario: &lt;b&gt;$REMOTE_USER&lt;/b&gt;&lt;br&gt;"
  
  echo "&lt;form action=\"/cgi-bin/controle/controle_post.cgi\" method=\"POST\"&gt;"
    
  echo "&lt;h3&gt;Qual destas operações voce deseja executar ?&lt;/h3&gt;"
  
  [ "$REMOTE_USER" = "gerente" ] &amp;&amp; {
  echo "&lt;input type=radio name=op value=halt&gt; Desligar máquina&lt;br&gt;"
  echo "&lt;input type=radio name=op value=reboot&gt; Reinicializar&lt;br&gt;"; }
  
  echo "
  &lt;input type=radio name=op value=w&gt; Ver quem esta logado&lt;br&gt;
  &lt;input type=radio name=op value=df&gt; Ver uso do disco&lt;br&gt;
  &lt;input type=submit value=Enviar&gt;
  &lt;/form&gt;
    
  &lt;/body&gt;
  &lt;/html&gt;"
  
  =================================================
</PRE>
<P>
Ok, especificamos que somente o usuário <I>gerente</I> terá acesso as opções
de <I>halt</I> e <I>reboot</I>.
Criamos o script que tratará este input.
<P>
<PRE>
  ================ controle_post.cgi ==============
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo "&lt;html&gt;&lt;head&gt;&lt;title&gt;Controle&lt;/title&gt;&lt;/head&gt;"
  echo "&lt;body&gt;"
  
  echo "Voce esta logado como usuario: &lt;b&gt;$REMOTE_USER&lt;/b&gt;&lt;br&gt;"
  op=$(sed '/./s/^op=//')
  
  case  "$op" 
  in
  
  	"halt" )
  		echo "desligando a maquina ..."
  		;;
  	"reboot" )
  		echo "reinicializando a maquina ..."
  		;;
  	"w" )
  		echo "Usuários logado:"
  		echo "&lt;pre&gt;$(who)&lt;/pre&gt;"
  		;;
  	"df" )
  		echo "Disco"
  		echo "&lt;pre&gt;$(df -Th)&lt;/pre&gt;"
  		;;
  	* )
  		echo "opcao invalida&lt;/body&gt;&lt;/html&gt;"
  		exit
  		;;
  esac
  echo "&lt;/body&gt;&lt;/html&gt;"
  =================================================
</PRE>
<P>
Bom, tudo tranqüilo. Script sem problemas. <B>NÃO</B>
<P>
Pois, se algum usuário olhar o source HTML da página
<CODE>http://localhost/cgi-bin/controle/controle.cgi</CODE>, ele verá os inputs do
FORM. Assim, ele sabe que o que é enviado pelo POST no nosso exemplo é
<I>op=xx</I>. 
Ele não enxergará as opções <I>halt</I> e <I>reboot</I>, mas ele perceberá que são
comandos e que o CGI é para executar algum comando sobre a máquina.
Então fizemos o seguinte comando.
<P>
<PRE>
  echo "op=halt" | lynx -dump -post-data -auth=user:senha \
  http://localhost/cgi-bin/controle/controle_post.cgi
</PRE>
<P>
<table align="center" cellpadding=4 border=1>
<tr>
<td>No <I>user:senha</I>, coloque um user e senha válido, mas use um user diferente de <I>gerente</I></td>
</tr>
</table>

<P>
Note que estamos indo direto a segunda página <I>controle_post.cgi</I>.
O lynx pra quem não sabe é um browser modo texto. No exemplo, ele está
enviando os dados que recebeu da entrada padrão via o método POST
para aquela URL.
<P>
Como no script controle_post.cgi não existe nenhum controle de usuário, o
nosso usuário != de gerente conseguiu desligar a nossa máquina. :/
<P>
Então vamos arrumar:
<P>
<PRE>
  ================ controle_post.cgi ==============
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo "&lt;html&gt;&lt;head&gt;&lt;title&gt;Controle&lt;/title&gt;&lt;/head&gt;"
  echo "&lt;body&gt;"
  
  echo "Voce esta logado como usuario: &lt;b&gt;$REMOTE_USER&lt;/b&gt;&lt;br&gt;"
  op=$(sed '/./s/^op=//')
  
  case  "$op" 
  in
  
  	"halt" )
  			[ "$REMOTE_USER" != "gerente" ] &amp;&amp; { echo "opcao invalida"
  			set &gt;&gt; "/tmp/CGI_halt_$REMOTE_ADDR"; echo "&lt;/body&gt;&lt;/html&gt;"; exit; }
  			echo "desligando a maquina ..."
  			;;
  	"reboot" )
  			[ "$REMOTE_USER" != "gerente" ] &amp;&amp; { echo "opcao invalida"
  			set &gt;&gt; "/tmp/CGI_reboot_$REMOTE_ADDR"; echo "&lt;/body&gt;&lt;/html&gt;"; exit; }
  			echo "reinicializando a maquina ..."
  			;;
  	"w" )
  			echo "Usuários logado:"
  			echo "&lt;pre&gt;$(who)&lt;/pre&gt;"
  			;;
  	"df" )
  			echo "Disco"
  			echo "&lt;pre&gt;$(df -Th)&lt;/pre&gt;"
  			;;
  	* )
  			echo "opcao invalida&lt;/body&gt;&lt;/html&gt;"
  			exit
  			;;
  esac
  echo "&lt;/body&gt;&lt;/html&gt;"
  =================================================
</PRE>
<P>
Moral da história: quando utilizar interação com o usuário tem que testar
tudo!!! teste, teste, teste. Verifique as opcões, variáveis, etc.
<P>
<a name="toc17"></a>
<H1>4. LAN  +_+</H1>
<P>
Exemplo prático. Vamos monitorar os host de nossa LAN. Saber quais estão
ativos, quais não respondem e informações sobre um determinado host.
Este fonte é apenas uma estrutura básica, mas server para se ter uma idéia
do quão poderoso pode ficar um CGI em Shell.
Crie os seguintes arquivos em /usr/lib/cgi-bin/lan
<P>
<PRE>
  ================ lan.cgi ========================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo "&lt;html&gt;"
  echo "&lt;head&gt;"
  echo "&lt;title&gt;Monitoramento da LAN&lt;/title&gt;"
  # Descomente se quiser auto refresh
  #echo "&lt;meta http-equiq=\"refresh\" content=\"10;url=/cgi-bin/lan/lan.cgi\"&gt;"
  echo "&lt;/head&gt;"
  
  echo "
  &lt;body bgcolor=white&gt;
  &lt;div align=right&gt;Usuário: &lt;b&gt;$REMOTE_USER&lt;/b&gt;&lt;/div&gt;
  &lt;center&gt;&lt;h2&gt;Máquinas da LAN&lt;/h2&gt;
  &lt;form method=\"post\" action=\"lan_info.cgi\"&gt;
  &lt;table widthborder=0 cellpadding=2&gt;"
  
  # arquivo contendo o nome dos host a monitorar
  FILE_host="host"
  maxcol=4
  numcol=1
  for host in $(cat "$FILE_host" | sort -g -tl -k2);do
  	[ $numcol = 1 ] &amp;&amp; echo "&lt;tr&gt;"
  	# depedendo da versao do ping existe a opcao -w, que especifica quantos
  	# segundo o ping deve esperar por resposta. coloque -w1 para agilizar o
  	# tempo de resposta
  	ping -c1 "$host" &gt; /dev/null 2&gt;&amp;1
  
  	if [ $? -eq 0 ];then
  		echo "&lt;td align=\"center\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;img src=\"/icons/penguin_on.jpg\" alt=\"$host OK\" border=0&gt;&lt;/a&gt;&lt;/td&gt;"
  		echo "&lt;td&gt;&lt;input type=radio name=host value=\"$host\"&gt;&lt;br&gt;$host&lt;/td&gt;"
  	elif [ $? -eq 1 ] ;then
  		echo "&lt;td align=\"center\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;img src=\"/icons/penguin_off.jpg\" alt=\"Sem reposta da $host\" border=0&gt;&lt;/a&gt;&lt;/td&gt;"
          echo "&lt;td&gt;&lt;br&gt;$host&lt;/td&gt;"
  	elif [ $? -eq 2 ] ;then 
  		echo "&lt;td align=\"center\"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;img src=\"/icons/penguin_off.jpg\" alt=\"$host nao existe\" border=0&gt;&lt;/a&gt;&lt;/td&gt;"
          echo "&lt;td&gt;&lt;br&gt;$host&lt;/td&gt;"
  	fi
  
  	[ $numcol = 4 ] &amp;&amp; { echo "&lt;/tr&gt;"; numcol=1; } || numcol=$(($numcol+1))
  done
  
  echo "
  &lt;/table&gt;&lt;br&gt;
  
  &lt;input type=submit name=\"botao\" value=\"info\"&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;
  &lt;input type=submit name=\"botao\" value=\"processos\"&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;
  
  &lt;/form&gt;
  &lt;/center&gt;
  &lt;/body&gt;&lt;/html&gt;"
  =================================================
</PRE>
<P>
Abaixo o script que receberá os pedidos da página principal.
Para buscar informações nos outros <I>hosts</I> estou utilizando um
<I>rsh</I>. Você também pode utilizar ssh, é só trocar.
<P>
PS: não se esqueça que para executar o rsh, ele precisa estar configurado e
não pedir senha. Para testar <I>rsh host ls</I>. O usuário default do Apache
não tem shell, assim você precisa rodá-lo com um outro usuário.
<P>
<PRE>
  ================ lan_info.cgi ===================
  #!/bin/bash
  
  echo "content-type: text/html"
  echo
  echo "&lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;Monitoramento da LAN&lt;/title&gt;&lt;/head&gt;
  
  &lt;body bgcolor=white&gt;
  &lt;div align=right&gt;Usuário: &lt;b&gt;$REMOTE_USER&lt;/b&gt;&lt;/div&gt;"
  
  VAR=$(sed -n '1p')
  host=$(echo "$VAR" | sed 's/^host=\(.*\)\&amp;.*$/\1/')
  botao=$(echo "$VAR" | cut -d= -f3)
  
  [ "$host" -a "$botao" ] || { echo "Opcao invalida&lt;/body&gt;&lt;/html&gt;";exit; }
  
  if [ "$botao" = "info" ];then
  	ip=$(ping -c1 "$host"  2&gt; /dev/null | sed -n '/^PING/{s/^.*(\([0-9\.]\+\)):.*$/\1/;p;}')
  	echo "&lt;center&gt;&lt;h2&gt;Informacoes da maquina: &lt;i&gt;$host&lt;/i&gt;&lt;/h2&gt;&lt;/center&gt;"
  	echo "&lt;strong&gt;Nome:&lt;/strong&gt; $host&lt;br&gt;"
  	echo "&lt;strong&gt;IP:&lt;/strong&gt;   $ip&lt;br&gt;"
  	echo "&lt;br&gt;"
  
  	saida=$(rsh "$host" cat /proc/version)
  	[ "$?" -eq "0" ] &amp;&amp; echo "&lt;strong&gt;Sistema Operacional&lt;/strong&gt;&lt;pre&gt;$saida&lt;/pre&gt;"
  
  	saida=$(rsh "$host" uptime)
  	[ "$?" -eq "0" ] &amp;&amp; echo "&lt;strong&gt;uptime&lt;/strong&gt;&lt;pre&gt;$saida&lt;/pre&gt;"
  
  
  	saida=$(rsh "$host" cat /proc/cpuinfo)
  	[ "$?" -eq "0" ] &amp;&amp; echo "&lt;strong&gt;Informacoes da CPU&lt;/strong&gt;&lt;pre&gt;$saida&lt;/pre&gt;"
  
  	saida=$(rsh "$host" free -ok)
  	[ "$?" -eq "0" ] &amp;&amp; echo "&lt;strong&gt;Informacoes de Memoria&lt;/strong&gt;&lt;pre&gt;$saida&lt;/pre&gt;"
  	mem=$(rsh $host cat /proc/meminfo)
  	percent=`echo "$mem" | sed -n '2p' | awk '{printf("%d",$3*100/$2)}'`
  	used=$(echo "$percent*2" | bc); free=$(echo "200-$percent*2" | bc)
  	echo "
  	&lt;table border=0 cellspacing=0 cellpadding=2&gt;
  	&lt;tr&gt;
  	&lt;td&gt;&lt;font size=\"3\"&gt;0%&lt;/font&gt;&lt;/td&gt;
  	&lt;td align=center width=$used bgcolor=red&gt;&lt;font size=\"3\" color=white&gt;$percent%&lt;/font&gt;&lt;/td&gt;
  	&lt;td width=$free bgcolor=green&gt;&lt;font size=\"3\"&gt;&amp;nbsp;&lt;/font&gt;&lt;/td&gt;
  	&lt;td&gt;&lt;font size=\"3\"&gt;100%&lt;/font&gt;&lt;/td&gt;
  	&lt;/tr&gt;
  	&lt;/table&gt;"
  	echo "&lt;br&gt;&lt;br&gt;&lt;strong&gt;Detalhes:&lt;/strong&gt;"
  	echo "&lt;pre&gt;$(echo "$mem" | sed '1,3d')"
  	echo "&lt;br&gt;&lt;br&gt;&lt;/pre&gt;"
  
  	echo "&lt;strong&gt;Informacoes de Disco&lt;/strong&gt;&lt;br&gt;"
  	echo "Discos SCSI &lt;br&gt;"
  	echo "&lt;pre&gt;$(rsh "$host" cat /proc/scsi/scsi 2&gt; /dev/null)&lt;/pre&gt;"
  
  	echo "Discos IDE:&lt;br&gt; "
  
  	for i in a b c d; do
  		TEMP=$(rsh "$host" "test -L \"/proc/ide/hd$i\" &amp;&amp; echo sim")
  		[ "$TEMP" = "sim" ] &amp;&amp; \
  		echo -n "hd$i : $(rsh "$host" cat "/proc/ide/hd$i/{media,model}" | sed 'N;s/\n/ /')&lt;br&gt;" 
  	done
  
  	echo "&lt;br&gt;Particoes dos Discos"
  	echo "&lt;pre&gt;$(rsh "$host" cat /proc/partitions)&lt;/pre&gt;"
  	echo "&lt;pre&gt;$(rsh "$host" df -Th)&lt;/pre&gt;"
  	echo "&lt;strong&gt;&lt;i&gt;swap&lt;/i&gt;&lt;/strong&gt;&lt;pre&gt;$(rsh "$host" cat /proc/swaps)&lt;/pre&gt;"
  
  
  elif [ "$botao" = "processos" ];then 
  	saida=$(rsh "$host" ps aux)
  	[ "$?" -eq "0" ] &amp;&amp; echo "&lt;strong&gt; Informacoes sobre os processos da \
  	maquina: &lt;i&gt;$host&lt;/i&gt;&lt;/strong&gt;&lt;pre&gt;$saida&lt;/pre&gt;"
  fi
  echo "&lt;/body&gt;&lt;/html&gt;"
  =================================================
</PRE>
<P>
Você precisa baixar estas duas imagens utilizadas para mostrar se os hosts
estão respondendo ou não. 
<table cellpadding=4 border=0>
<tr>
<td><IMG ALIGN="middle" SRC="penguin_on.jpg" BORDER="0"></td>
<td><IMG ALIGN="middle" SRC="penguin_off.jpg" BORDER="0"></td>
</tr>
</table>

<P>
<a name="toc18"></a>
<H1>5. Resumão</H1>
<B><I>POST &amp; GET</I></B>
<P>
No GET você pega as opções através da variável de ambiente
<B><I>$QUERY_STRING</I></B>. No POST você pega através da entrada padrão, ex:
<PRE>
  VAR=$(sed -n '1p')
</PRE>
Após isto é só pegar as opções nestas variáveis e fazer o script
necessário.
<P>
<HR NOSHADE SIZE=5>
<P>
Bom, com este texto espero ter dado uma visão geral de como funciona CGI em
Shell Script. Assim que tiver tempo vou procurar incrementar o texto
adicionando novos exemplo, explicando mais os conceitos... 
<P>
Se você quiser contribuir, me envie um <A HREF="mailto:thobias@lcp.coppe.ufrj.br">mail</A> =8)
<P>
<table cellpadding=4 border=1>
<tr>
<td><B>Pessoas que ajudaram</B></td>
</tr>
</table>

<P>
<UL>
<LI>Silvano B. Dias
<LI>Aurélio Marinho Jargas
<LI>Vinícius Della Líbera
<LI>Julio Cezar Neves
</UL>
<HR NOSHADE SIZE=1>
<P>
This HTML page is <A HREF="http://txt2tags.sf.net"><IMG ALIGN="middle" SRC="pwrbytxt2tags-2.png" BORDER="0"></A>
(see <A HREF="cgi_shell.t2t">source</A>)
<P>

<!-- html code generated by txt2tags 1.6 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags -\-toc -t html -\-enumtitle cgi_shell.t2t -->
</BODY></HTML>
